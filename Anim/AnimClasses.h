/*=============================================================================
	C++ class definitions exported from script.
	This is automatically generated by the tools.
	DO NOT modify this manually! Edit the corresponding .uc files instead!
=============================================================================*/


#ifndef __ANIMCLASSES_H__
#define __ANIMCLASSES_H__

/*-----------------------------------------------------------------------------
	Forward declarations
-----------------------------------------------------------------------------*/

class CAnimNode;
class CAnimSet;
class CAnimTree;
class CSkeletalMesh;


/*-----------------------------------------------------------------------------
	CAnimNode class (declared in AnimNode.uc)
-----------------------------------------------------------------------------*/

#define MAX_NODE_NAME			64
#define MAX_NODE_LABEL			32

struct CAnimNodeData
{
	bool						Relevant;
	float						TotalWeight;
	/**
	 * Value, controlling AnimNode blending. When scalar used, Y component is ignored.
	 */
	float						ControlX;
	float						ControlY;
};


/**
 * Structure describing children (by tree hierarchy) of this AnimNode.
 * Really, this is an one of input values for this AnimNode.
 */
struct CAnimNodeChild
{
	TString<MAX_NODE_LABEL>		Label;
	CAnimNode*					Node;

	friend CArchive& operator<<(CArchive &Ar, CAnimNodeChild &C);
		// cannot embed code here: uses undefined class CAnimNode
};


class CAnimNode : public CObject
{
	DECLARE_CLASS(CAnimNode, CObject)
public:
	/**
	 * This is the name used to find an AnimNode by name from a tree
	 */
	TString<MAX_NODE_NAME>		Name;
	/**
	 * AnimTree this node belongs to
	 */
	CAnimTree*					Owner;
	/**
	 * Parent nodes by AnimTree hierarchy. These nodes uses output from this node
	 * as input value.
	 */
	TArray<CAnimNode*>			Parents;
	/**
	 * Nodes, provides input values for this AnimNode
	 */
	TArray<CAnimNodeChild>		Children;
	/**
	 * Rectangle
	 */
	int							DrawX;
	/**
	 * Rectangle
	 */
	int							DrawY;
	int							DrawWidth;
	int							DrawHeight;
	/**
	 * Node output
	 */
	int							OutDrawY;

	friend class CSkelMeshInstance;

#define DECLARE_ANIMDATA(DataType)	\
	typedef C##DataType NodeData_t;	\
	virtual int GetDataSize() const	\
	{								\
		return sizeof(C##DataType);	\
	}
	/*?? also add to DECLARE_ANIMDATA():
	virtual void Tick(void *Data) -- virtual ticker (different function name!)
	{
		Tick((DataType*)Data); -- non-virtual local ticker
	}
	void Tick(CSkelMeshInstance *Inst, DataType *Data, CBoneAtom *Bones)
	{
		CBoneAtom BonesA[MAX_MESH_BONES], BonesB[MAX_MESH_BONES];
		-- find relevant Children A and B + weights
		-- call Child[A].Tick(BonesA) and Child[B].Tick(BonesB)
		-- blend(BonesA, BonesB) -> Bones
		--!! should also pass bool array of bones to compute (for BlendPerBone nodes)

		--!! AnimPlayer should simply copy data from animation track to Bones[],
		--!! but with remapping Mesh <-> AnimSet bones; note: bone remap is required
		--!! for AnimPlayer only.
	}
	*/

	DECLARE_ANIMDATA(AnimNodeData)

	virtual void Serialize(CArchive &Ar)
	{
		Super::Serialize(Ar);
		Ar << Name << Parents << Children;
	}
};


/*-----------------------------------------------------------------------------
	CAnimSet class (declared in AnimSet.uc)
-----------------------------------------------------------------------------*/

#define MAX_BONE_NAME			32
#define MAX_ANIM_NAME			64

struct CAnimBone
{
	TString<MAX_BONE_NAME>		Name;

	friend CArchive& operator<<(CArchive &Ar, CAnimBone &B)
	{
		return Ar << B.Name;
	}
};


/**
 * Raw keyframe data for one track.  Each array will contain either NumKey elements or 1 element.
 * One element is used as a simple compression scheme where if all keys are the same, they'll be
 * reduced to 1 key that is constant over the entire sequence.
 */
struct CAnalogTrack
{
	/**
	 * Rotation keys
	 */
	TArray<CQuat>				KeyQuat;
	/**
	 * Position keys
	 */
	TArray<CVec3>				KeyPos;
	TArray<CVec3>				KeyScale;
	/**
	 * Key times, in seconds
	 */
	TArray<float>				KeyTime;

	friend CArchive& operator<<(CArchive &Ar, CAnalogTrack &T)
	{
		return Ar << T.KeyQuat << T.KeyPos << T.KeyScale << T.KeyTime;
	}
};


struct CAnimNotify
{
	float						Time;

	friend CArchive &operator<<(CArchive &Ar, CAnimNotify &N)
	{
		return Ar << N.Time;
	}
};


struct CMeshAnimSeq
{
	/**
	 * Name of the animation sequence
	 */
	TString<MAX_ANIM_NAME>		Name;
	/**
	 * Number for tweaking playback rate of this animation globally
	 */
	float						Rate;
	/**
	 * Length (in seconds) of this AnimSequence if played back with a speed of 1
	 */
	int							NumFrames;
	/**
	 * Raw keyframe data for this sequence
	 */
	TArray<CAnalogTrack>		Tracks;
	TArray<CAnimNotify>			Notifies;

	/**
	 * Interpolate bone position from animation track for specified time
	 */
	void GetBonePosition(int TrackIndex, float Frame, bool Loop, CVec3 &DstPos, CQuat &DstQuat) const;
	/**
	 * Query size statistics about this animation sequence
	 */
	void GetMemFootprint(int *Compressed, int *Uncompressed = NULL);

	friend CArchive &operator<<(CArchive &Ar, CMeshAnimSeq &A)
	{
		return Ar << A.Name << A.Rate << A.NumFrames << A.Tracks << A.Notifies;
	}
};


/**
 * This is a set of AnimSequences
 * All sequence have the same number of tracks, and they relate to the same bone names.
 */
class CAnimSet : public CObject
{
	DECLARE_CLASS(CAnimSet, CObject)
public:
	/**
	 * Bone name that each track relates to. TrackBoneName.Num() == Number of tracks.
	 */
	TArray<CAnimBone>			TrackBoneName;
	/**
	 * Actual animation sequence information
	 */
	TArray<CMeshAnimSeq>		Sequences;
	/**
	 * Indicates that only the rotation should be taken from the animation sequence and the translation
	 * should come from the SkeletalMesh ref pose. Note that the root bone always takes translation from
	 * the animation, even if this flag is set.
	 */
	bool						AnimRotationOnly;

	CAnimSet()
	:	AnimRotationOnly(false)
	{}

	/**
	 * Query size statistics about all animation sequences
	 */
	void GetMemFootprint(int *Compressed, int *Uncompressed = NULL);
	/**
	 * Find animation sequence by name. Case-insensitive search. When animation is not
	 * found, returns NULL.
	 */
	const CMeshAnimSeq *FindAnim(const char *AnimName) const;

	virtual void Serialize(CArchive &Ar)
	{
		Super::Serialize(Ar);
		Ar << TrackBoneName << Sequences << AnimRotationOnly;
	}
};


/*-----------------------------------------------------------------------------
	CAnimTree class (declared in AnimTree.uc)
-----------------------------------------------------------------------------*/


struct CAnimControl
{
	TString<MAX_NODE_LABEL>		Name;

	friend CArchive &operator<<(CArchive &Ar, CAnimControl &A)
	{
		return Ar << A.Name;
	}
};


class CAnimTree : public CAnimNode
{
	DECLARE_CLASS(CAnimTree, CAnimNode)
public:
	TArray<CAnimNode*>			AllNodes;
	TArray<CAnimControl>		Controls;

	virtual void Serialize(CArchive &Ar)
	{
		Super::Serialize(Ar);
		Ar << Controls << AllNodes;
	}

	virtual void PostLoad()
	{
		for (int i = 0; i < AllNodes.Num(); i++)
			AllNodes[i]->Owner = this;
	}
};


/*-----------------------------------------------------------------------------
	CSkeletalMesh class (declared in SkeletalMesh.uc)
-----------------------------------------------------------------------------*/

#define MAX_MESH_BONES			256
#define MAX_MESH_MATERIALS		256
#define MAX_FILE_PATH			64
#define MAX_VERTEX_INFLUENCES	4
#define NO_INFLUENCE			-1
#define MESH_EXTENSION			"skm"
#define ANIM_EXTENSION			"ska"

struct CPointWeight
{
	/**
	 * NO_INFLUENCE == entry not used
	 */
	short						BoneIndex;
	/**
	 * 0==0.0f, 65535==1.0f
	 */
	word						Weight;

	friend CArchive& operator<<(CArchive &Ar, CPointWeight &W)
	{
		return Ar << W.BoneIndex << W.Weight;
	}
};


/**
 * Rendering vertex structure
 */
struct CMeshPoint
{
	CVec3						Point;
	CVec3						Normal;
	float						U;
	float						V;
	CPointWeight				Influences[MAX_VERTEX_INFLUENCES];

	friend CArchive& operator<<(CArchive &Ar, CMeshPoint &P)
	{
		Ar << P.Point << P.Normal << P.U << P.V;
		for (int i = 0; i < MAX_VERTEX_INFLUENCES; i++)
			Ar << P.Influences[i];
		return Ar;
	}
};


struct CMeshBone
{
	TString<MAX_BONE_NAME>		Name;
	CVec3						Position;
	CQuat						Orientation;
	int							ParentIndex;
	/**
	 * following data generated after mesh loading
	 */
	CCoords						InvRefCoords;
	int							SubtreeSize;

	friend CArchive& operator<<(CArchive &Ar, CMeshBone &B)
	{
		return Ar << B.Name << B.Position << B.Orientation << AR_INDEX(B.ParentIndex);
	}
};


struct CMeshHitBox
{
	/**
	 * Name of this volume
	 */
	TString<MAX_BONE_NAME>		Name;
	/**
	 * Associates this box with bone in a skeletal mesh
	 */
	int							BoneIndex;
	/**
	 * Bounding volume (oriented bounding box)
	 * Box occupy a volume (-0.5,-0.5,-0.5)-(0.5,0.5,0.5) in local coordinate system
	 */
	CCoords						Coords;

	friend CArchive& operator<<(CArchive &Ar, CMeshHitBox &B)
	{
		return Ar << B.Name << AR_INDEX(B.BoneIndex) << B.Coords;
	}
};


/**
 * Defines a named attachment location on the SkeletalMesh
 */
struct CMeshSocket
{
	/**
	 * Name of attachment
	 */
	TString<MAX_BONE_NAME>		Name;
	/**
	 * Associates this socket with bone in a skeletal mesh
	 */
	int							BoneIndex;
	/**
	 * Coordinate system of socket, relative to parent bone's coordinates
	 */
	CCoords						Coords;

	friend CArchive& operator<<(CArchive &Ar, CMeshSocket &S)
	{
		return Ar << S.Name << AR_INDEX(S.BoneIndex) << S.Coords;
	}
};


/**
 * Structure, describing single mesh section (for rendering)
 */
struct CMeshSection
{
	/**
	 * Index in Mesh.Materials array
	 */
	int							MaterialIndex;
	/**
	 * First index, corresponding to this section in MeshLod.Indices array
	 */
	int							FirstIndex;
	/**
	 * Number of section indices in MeshLod.Indices
	 */
	int							NumIndices;

	friend CArchive& operator<<(CArchive &Ar, CMeshSection &S)
	{
		return Ar << AR_INDEX(S.MaterialIndex) << S.FirstIndex << S.NumIndices;
	}
};


/**
 * Visualization mesh. Contains geometry only. Materials, skeleton etc
 * shared between all lod levels in SkeletalMesh class.
 */
struct CSkeletalMeshLod
{
	/**
	 * Separate renderable mesh parts
	 */
	TArray<CMeshSection>		Sections;
	/**
	 * Vertices of whole mesh (for all sections)
	 */
	TArray<CMeshPoint>			Points;
	/**
	 * Index buffer for whole mesh
	 */
	TArray<int>					Indices;

	friend CArchive& operator<<(CArchive &Ar, CSkeletalMeshLod &L)
	{
		return Ar << L.Sections << L.Points << L.Indices;
	}
};


struct CMeshMaterial
{
	/**
	 * Name of the material file
	 */
	TString<MAX_FILE_PATH>		Filename;
	/**
	 * Material, used internally in renderer
	 */
	class CRenderingMaterial*	RenMaterial;

	friend CArchive& operator<<(CArchive &Ar, CMeshMaterial &M)
	{
		return Ar << M.Filename;
	}
};


class CSkeletalMesh : public CObject
{
	DECLARE_CLASS(CSkeletalMesh, CObject)
public:
	/**
	 * Origin in original coordinate system
	 */
	CVec3						MeshOrigin;
	/**
	 * Amount to scale mesh when importing
	 */
	CVec3						MeshScale;
	/**
	 * Amount to rotate when importing
	 */
	CRotator					RotOrigin;
	/**
	 * Information for LOD levels
	 */
	TArray<CSkeletalMeshLod>	Lods;
	/**
	 * Skeleton bones
	 */
	TArray<CMeshBone>			Skeleton;
	/**
	 * Collision volumes
	 */
	TArray<CMeshHitBox>			BoundingBoxes;
	/**
	 * Attachment sockets
	 */
	TArray<CMeshSocket>			Sockets;
	/**
	 * List of materials applied to this mesh
	 */
	TArray<CMeshMaterial>		Materials;
	/**
	 * Following data generated after loading
	 */
	CCoords						BaseTransform;
	CCoords						BaseTransformScaled;

	CSkeletalMesh();
	virtual ~CSkeletalMesh();
	virtual void PostLoad();
	virtual void PostEditChange();
	/**
	 * Case-insensitive bone search. If bone found, returns its index, or -1 otherwise.
	 */
	int FindBone(const char *BoneName) const;
	/**
	 * Dump bone hierarchy to console
	 */
	void DumpBones();
#if EDITOR
	/**
	 * Editor: bind material from 'Materials' array for rendering. Return false when
	 * material cannot be bound (for example, texture was not loaded).
	 */
	bool BindMaterial(int index) const;
#endif

	virtual void Serialize(CArchive &Ar)
	{
		Super::Serialize(Ar);
		Ar << MeshOrigin << MeshScale << RotOrigin << Lods << Skeleton << Materials
		   << BoundingBoxes << Sockets;
	}
};


/*-----------------------------------------------------------------------------
	Class registration
-----------------------------------------------------------------------------*/

#define REGISTER_ANIM_CLASSES \
	REGISTER_CLASS(CAnimSet) \
	REGISTER_CLASS(CAnimTree) \
	REGISTER_CLASS(CSkeletalMesh)


#endif // __ANIMCLASSES_H__
