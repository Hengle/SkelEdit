#ifndef __PSK_H__
#define __PSK_H__


/******************************************************************************
 *	Common structures
 *****************************************************************************/

struct VChunkHeader
{
	char			ChunkID[20];
	int				TypeFlag;
	int				DataSize;
	int				DataCount;

	friend CArchive& operator<<(CArchive &Ar, VChunkHeader &H)
	{
		Ar.Serialize(ARRAY_ARG(H.ChunkID));
		return Ar << H.TypeFlag << H.DataSize << H.DataCount;
	}
};

#define LOAD_CHUNK(var, name)	\
	VChunkHeader var;			\
	Ar << var;					\
	if (strcmp(var.ChunkID, name) != 0) \
		appError("LoadChunk: expecting header \"%s\", but found \"%s\"", name, var.ChunkID);
//	appPrintf("%s: type=%d / count=%d / size=%d\n", var.ChunkID, var.TypeFlag, var.DataCount, var.DataSize);



/******************************************************************************
 *	PSK file format structures
 *****************************************************************************/

struct VVertex
{
	int				PointIndex;				// short, padded to int
	float			U, V;
	byte			MatIndex;
	byte			Reserved;
	short			Pad;					// not used

	friend CArchive& operator<<(CArchive &Ar, VVertex &V)
	{
		Ar << V.PointIndex << V.U << V.V << V.MatIndex << V.Reserved << V.Pad;
		return Ar;
	}
};


struct VTriangle16
{
	word			WedgeIndex[3];			// Point to three vertices in the vertex list.
	byte			MatIndex;				// Materials can be anything.
	byte			AuxMatIndex;			// Second material (unused).
	unsigned		SmoothingGroups;		// 32-bit flag for smoothing groups.

	friend CArchive& operator<<(CArchive &Ar, VTriangle16 &T)
	{
		Ar << T.WedgeIndex[0] << T.WedgeIndex[1] << T.WedgeIndex[2];
		Ar << T.MatIndex << T.AuxMatIndex << T.SmoothingGroups;
		return Ar;
	}
};


// the same as VTriangle16 but with 32-bit vertex indices
//!! note: this structure has different on-disk and in-memory layout and size (due to alignment)
struct VTriangle32
{
	int				WedgeIndex[3];			// Point to three vertices in the vertex list.
	byte			MatIndex;				// Materials can be anything.
	byte			AuxMatIndex;			// Second material (unused).
	unsigned		SmoothingGroups;		// 32-bit flag for smoothing groups.

	// original psk VTriangle
	friend void SerializeTriangle16(CArchive &Ar, VTriangle32 &T)
	{
		if (Ar.IsLoading)
		{
			// high-order words should be zeroed
			T.WedgeIndex[0] = T.WedgeIndex[1] = T.WedgeIndex[2] = 0;
		}
		Ar << ((short&)T.WedgeIndex[0]) << ((short&)T.WedgeIndex[1]) << ((short&)T.WedgeIndex[2]);
		Ar << T.MatIndex << T.AuxMatIndex << T.SmoothingGroups;
	}

	// extended VTriangle with 32-bit WedgeIndex
	friend void SerializeTriangle32(CArchive &Ar, VTriangle32 &T)
	{
		Ar << T.WedgeIndex[0] << T.WedgeIndex[1] << T.WedgeIndex[2];
		Ar << T.MatIndex << T.AuxMatIndex << T.SmoothingGroups;
	}
};


struct VMaterial
{
	char			MaterialName[64];
	int				TextureIndex;
	unsigned		PolyFlags;
	int				AuxMaterial;
	unsigned		AuxFlags;
	int				LodBias;
	int				LodStyle;

	friend CArchive& operator<<(CArchive &Ar, VMaterial &M)
	{
		Ar.Serialize(ARRAY_ARG(M.MaterialName));
		return Ar << M.TextureIndex << M.PolyFlags << M.AuxMaterial <<
					 M.AuxFlags << M.LodBias << M.LodStyle;
	}
};


// A bone: an orientation, and a position, all relative to their parent.
struct VJointPos
{
	CQuat			Orientation;
	CVec3			Position;
	float			Length;
	CVec3			Size;

	friend CArchive& operator<<(CArchive &Ar, VJointPos &P)
	{
		return Ar << P.Orientation << P.Position << P.Length << P.Size;
	}
};


struct VBone
{
	char			Name[64];
	unsigned		Flags;
	int				NumChildren;
	int				ParentIndex;			// 0 if this is the root bone.
	VJointPos		BonePos;

	friend CArchive& operator<<(CArchive &Ar, VBone &B)
	{
		Ar.Serialize(ARRAY_ARG(B.Name));
		return Ar << B.Flags << B.NumChildren << B.ParentIndex << B.BonePos;
	}
};


struct VRawBoneInfluence
{
	float			Weight;
	int				PointIndex;
	int				BoneIndex;

	friend CArchive& operator<<(CArchive &Ar, VRawBoneInfluence &I)
	{
		return Ar << I.Weight << I.PointIndex << I.BoneIndex;
	}
};


/******************************************************************************
 *	PSA file format structures
 *****************************************************************************/

// Binary bone format to deal with raw animations as generated by various exporters.
struct FNamedBoneBinary
{
	char			Name[64];				// Bone's name
	unsigned		Flags;					// reserved
	int				NumChildren;
	int				ParentIndex;			// 0/NULL if this is the root bone.
	VJointPos		BonePos;

	friend CArchive& operator<<(CArchive &Ar, FNamedBoneBinary &B)
	{
		Ar.Serialize(ARRAY_ARG(B.Name));
		return Ar << B.Flags << B.NumChildren << B.ParentIndex << B.BonePos;
	}
};


// Binary animation info format - used to organize raw animation keys into FAnimSeqs on rebuild
// Similar to MotionChunkDigestInfo.
struct AnimInfoBinary
{
	char			Name[64];				// Animation's name
	char			Group[64];				// Animation's group name

	int				TotalBones;				// TotalBones * NumRawFrames is number of animation keys to digest.

	int				RootInclude;			// 0 none 1 included (unused)
	int				KeyCompressionStyle;	// Reserved: variants in tradeoffs for compression.
	int				KeyQuotum;				// Max key quotum for compression; ActorX sets this to numFrames*numBones
	float			KeyReduction;			// desired
	float			TrackTime;				// explicit - can be overridden by the animation rate
	float			AnimRate;				// frames per second.
	int				StartBone;				// Reserved: for partial animations
	int				FirstRawFrame;			// global number of first animation frame
	int				NumRawFrames;			// NumRawFrames and AnimRate dictate tracktime...

	friend CArchive& operator<<(CArchive &Ar, AnimInfoBinary &A)
	{
		Ar.Serialize(ARRAY_ARG(A.Name));
		Ar.Serialize(ARRAY_ARG(A.Group));
		return Ar << A.TotalBones << A.RootInclude << A.KeyCompressionStyle <<
					 A.KeyQuotum << A.KeyReduction << A.TrackTime << A.AnimRate <<
					 A.StartBone << A.FirstRawFrame << A.NumRawFrames;
	}
};


struct VQuatAnimKey
{
	CVec3			Position;				// Relative to parent
	CQuat			Orientation;			// Relative to parent
	float			Time;					// The duration until the next key (end key wraps to first ...)
	// NOTE: Maya ActorX does not initialize "Time" field, so assume 1.0f here.

	friend CArchive& operator<<(CArchive &Ar, VQuatAnimKey &K)
	{
		return Ar << K.Position << K.Orientation << K.Time;
	}
};


#endif // __PSK_H__
